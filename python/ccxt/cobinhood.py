# -*- coding: utf-8 -*-

# PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
# https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

from ccxt.base.exchange import Exchange
import json
from ccxt.base.errors import ExchangeError
from ccxt.base.errors import PermissionDenied
from ccxt.base.errors import InsufficientFunds
from ccxt.base.errors import InvalidAddress
from ccxt.base.errors import InvalidOrder
from ccxt.base.errors import OrderNotFound
from ccxt.base.errors import NotSupported
from ccxt.base.errors import InvalidNonce
from ccxt.base.errors import RequestTimeout


class cobinhood(Exchange):

    def describe(self):
        return self.deep_extend(super(cobinhood, self).describe(), {
            'id': 'cobinhood',
            'name': 'COBINHOOD',
            'countries': ['TW'],
            'rateLimit': 1000 / 10,
            'version': 'v1',
            'has': {
                'fetchCurrencies': True,
                'fetchTickers': True,
                'fetchOHLCV': True,
                'fetchOpenOrders': True,
                'fetchClosedOrders': True,
                'fetchOrderTrades': True,
                'fetchOrder': True,
                'fetchDepositAddress': True,
                'createDepositAddress': True,
                'fetchDeposits': True,
                'fetchWithdrawals': True,
                'withdraw': True,
                'fetchMyTrades': True,
                'editOrder': True,
            },
            'requiredCredentials': {
                'apiKey': True,
                'secret': False,
            },
            'timeframes': {
                # the first two don't seem to work at all
                '1m': '1m',
                '5m': '5m',
                '15m': '15m',
                '30m': '30m',
                '1h': '1h',
                '3h': '3h',
                '6h': '6h',
                '12h': '12h',
                '1d': '1D',
                '1w': '7D',
                '2w': '14D',
                '1M': '1M',
            },
            'urls': {
                'referral': 'https://cobinhood.com?referrerId=a9d57842-99bb-4d7c-b668-0479a15a458b',
                'logo': 'https://user-images.githubusercontent.com/1294454/35755576-dee02e5c-0878-11e8-989f-1595d80ba47f.jpg',
                'api': 'https://api.cobinhood.com',
                'www': 'https://cobinhood.com',
                'doc': 'https://cobinhood.github.io/api-public',
            },
            'api': {
                'system': {
                    'get': [
                        'info',
                        'time',
                        'messages',
                        'messages/{message_id}',
                    ],
                },
                'admin': {
                    'get': [
                        'system/messages',
                        'system/messages/{message_id}',
                    ],
                    'post': [
                        'system/messages',
                    ],
                    'patch': [
                        'system/messages/{message_id}',
                    ],
                    'delete': [
                        'system/messages/{message_id}',
                    ],
                },
                'public': {
                    'get': [
                        'market/fundingbook/precisions/{currency_id}',
                        'market/fundingbooks/{currency_id}',
                        'market/tickers',
                        'market/currencies',
                        'market/quote_currencies',
                        'market/trading_pairs',
                        'market/orderbook/precisions/{trading_pair_id}',
                        'market/orderbooks/{trading_pair_id}',
                        'market/stats',
                        'market/tickers',  # fetchTickers
                        'market/tickers/{trading_pair_id}',
                        'market/trades/{trading_pair_id}',
                        'market/trades_history/{trading_pair_id}',
                        'market/trading_pairs',
                        'chart/candles/{trading_pair_id}',
                        'system/time',
                    ],
                },
                'private': {
                    'get': [
                        'funding/auto_offerings',
                        'funding/auto_offerings/{currency_id}',
                        'funding/funding_history',
                        'funding/fundings',
                        'funding/loans',
                        'funding/loans/{loan_id}',
                        'trading/orders/{order_id}',
                        'trading/orders/{order_id}/trades',
                        'trading/orders',
                        'trading/order_history',
                        'trading/positions',
                        'trading/positions/{trading_pair_id}',
                        'trading/positions/{trading_pair_id}/claimable_size',
                        'trading/trades',
                        'trading/trades/{trade_id}',
                        'trading/volume',
                        'wallet/balances',
                        'wallet/ledger',
                        'wallet/limits/withdrawal',
                        'wallet/generic_deposits',
                        'wallet/generic_deposits/{generic_deposit_id}',
                        'wallet/generic_withdrawals',
                        'wallet/generic_withdrawals/{generic_withdrawal_id}',
                        # older endpoints
                        'wallet/deposit_addresses',
                        'wallet/deposit_addresses/iota',
                        'wallet/withdrawal_addresses',
                        'wallet/withdrawal_frozen',
                        'wallet/withdrawals/{withdrawal_id}',
                        'wallet/withdrawals',
                        'wallet/deposits/{deposit_id}',
                        'wallet/deposits',
                    ],
                    'patch': [
                        'trading/positions/{trading_pair_id}',
                    ],
                    'post': [
                        'funding/auto_offerings',
                        'funding/fundings',
                        'trading/check_order',
                        'trading/orders',
                        # older endpoints
                        'wallet/deposit_addresses',
                        'wallet/transfer',
                        'wallet/withdrawal_addresses',
                        'wallet/withdrawals',
                        'wallet/withdrawals/fee',
                    ],
                    'put': [
                        'funding/fundings/{funding_id}',
                        'trading/orders/{order_id}',
                    ],
                    'delete': [
                        'funding/auto_offerings/{currency_id}',
                        'funding/fundings/{funding_id}',
                        'funding/loans/{loan_id}',
                        'trading/orders/{order_id}',
                        'trading/positions/{trading_pair_id}',
                        'wallet/generic_withdrawals/{generic_withdrawal_id}',
                        'wallet/withdrawal_addresses/{wallet_id}',
                    ],
                },
            },
            'fees': {
                'trading': {
                    'maker': 0.0,
                    'taker': 0.0,
                },
            },
            'precision': {
                'amount': 8,
                'price': 8,
            },
            'exceptions': {
                'insufficient_balance': InsufficientFunds,
                'invalid_order_size': InvalidOrder,
                'invalid_nonce': InvalidNonce,
                'unauthorized_scope': PermissionDenied,
                'invalid_address': InvalidAddress,
                'parameter_error': OrderNotFound,
            },
            'commonCurrencies': {
                'SMT': 'SocialMedia.Market',
                'MTN': 'Motion Token',
            },
            'wsconf': {
                'conx-tpls': {
                    'default': {
                        'type': 'ws',
                        'baseurl': 'wss://ws.cobinhood.com/v2/ws',
                    },
                },
                'methodmap': {
                    '_websocketSendHeartbeat': '_websocketSendHeartbeat',
                    '_websocketTimeoutRemoveNonce': '_websocketTimeoutRemoveNonce',
                    '_websocketPongTimeout': '_websocketPongTimeout',
                },
                'events': {
                    'ob': {
                        'conx-tpl': 'default',
                        'conx-param': {
                            'url': '{baseurl}',
                            'id': '{id}',
                        },
                    },
                    'ticker': {
                        'conx-tpl': 'default',
                        'conx-param': {
                            'url': '{baseurl}',
                            'id': '{id}',
                        },
                    },
                    'ohlcv': {
                        'conx-tpl': 'default',
                        'conx-param': {
                            'url': '{baseurl}',
                            'id': '{id}',
                        },
                    },
                    'trade': {
                        'conx-tpl': 'default',
                        'conx-param': {
                            'url': '{baseurl}',
                            'id': '{id}',
                        },
                    },
                },
            },
        })

    def fetch_currencies(self, params={}):
        response = self.publicGetMarketCurrencies(params)
        currencies = response['result']['currencies']
        result = {}
        for i in range(0, len(currencies)):
            currency = currencies[i]
            id = self.safe_string(currency, 'currency')
            name = self.safe_string(currency, 'name')
            code = self.safe_currency_code(id)
            minUnit = self.safe_float(currency, 'min_unit')
            result[code] = {
                'id': id,
                'code': code,
                'name': name,
                'active': True,
                'fiat': False,
                'precision': self.precision_from_string(currency['min_unit']),
                'limits': {
                    'amount': {
                        'min': minUnit,
                        'max': None,
                    },
                    'price': {
                        'min': minUnit,
                        'max': None,
                    },
                    'deposit': {
                        'min': minUnit,
                        'max': None,
                    },
                    'withdraw': {
                        'min': minUnit,
                        'max': None,
                    },
                },
                'funding': {
                    'withdraw': {
                        'fee': self.safe_float(currency, 'withdrawal_fee'),
                    },
                    'deposit': {
                        'fee': self.safe_float(currency, 'deposit_fee'),
                    },
                },
                'info': currency,
            }
        return result

    def fetch_markets(self, params={}):
        response = self.publicGetMarketTradingPairs(params)
        markets = self.safe_value(response['result'], 'trading_pairs')
        result = []
        for i in range(0, len(markets)):
            market = markets[i]
            id = self.safe_string(market, 'id')
            baseId, quoteId = id.split('-')
            base = self.safe_currency_code(baseId)
            quote = self.safe_currency_code(quoteId)
            symbol = base + '/' + quote
            precision = {
                'amount': 8,
                'price': self.precision_from_string(market['quote_increment']),
            }
            active = self.safe_value(market, 'is_active', True)
            result.append({
                'id': id,
                'symbol': symbol,
                'base': base,
                'quote': quote,
                'baseId': baseId,
                'quoteId': quoteId,
                'active': active,
                'precision': precision,
                'limits': {
                    'amount': {
                        'min': self.safe_float(market, 'base_min_size'),
                        'max': self.safe_float(market, 'base_max_size'),
                    },
                    'price': {
                        'min': None,
                        'max': None,
                    },
                    'cost': {
                        'min': None,
                        'max': None,
                    },
                },
                'info': market,
            })
        return result

    def parse_ticker(self, ticker, market=None):
        symbol = None
        if market is None:
            marketId = self.safe_string(ticker, 'trading_pair_id')
            if marketId in self.markets_by_id:
                market = self.markets_by_id[marketId]
            else:
                baseId, quoteId = marketId.split('-')
                base = self.safe_currency_code(baseId)
                quote = self.safe_currency_code(quoteId)
                symbol = base + '/' + quote
        if market is not None:
            symbol = market['symbol']
        timestamp = self.safe_integer(ticker, 'timestamp')
        last = self.safe_float(ticker, 'last_trade_price')
        return {
            'symbol': symbol,
            'timestamp': timestamp,
            'datetime': self.iso8601(timestamp),
            'high': self.safe_float(ticker, '24h_high'),
            'low': self.safe_float(ticker, '24h_low'),
            'bid': self.safe_float(ticker, 'highest_bid'),
            'bidVolume': None,
            'ask': self.safe_float(ticker, 'lowest_ask'),
            'askVolume': None,
            'vwap': None,
            'open': None,
            'close': last,
            'last': last,
            'previousClose': None,
            'change': self.safe_float(ticker, 'percentChanged24hr'),
            'percentage': None,
            'average': None,
            'baseVolume': self.safe_float(ticker, '24h_volume'),
            'quoteVolume': self.safe_float(ticker, 'quote_volume'),
            'info': ticker,
        }

    def fetch_ticker(self, symbol, params={}):
        self.load_markets()
        market = self.market(symbol)
        request = {
            'trading_pair_id': market['id'],
        }
        response = self.publicGetMarketTickersTradingPairId(self.extend(request, params))
        ticker = self.safe_value(response['result'], 'ticker')
        return self.parse_ticker(ticker, market)

    def fetch_tickers(self, symbols=None, params={}):
        self.load_markets()
        response = self.publicGetMarketTickers(params)
        tickers = self.safe_value(response['result'], 'tickers')
        result = []
        for i in range(0, len(tickers)):
            result.append(self.parse_ticker(tickers[i]))
        return self.index_by(result, 'symbol')

    def fetch_order_book(self, symbol, limit=None, params={}):
        self.load_markets()
        request = {
            'trading_pair_id': self.market_id(symbol),
        }
        if limit is not None:
            request['limit'] = limit  # 100
        response = self.publicGetMarketOrderbooksTradingPairId(self.extend(request, params))
        return self.parse_order_book(response['result']['orderbook'], None, 'bids', 'asks', 0, 2)

    def parse_trade(self, trade, market=None):
        symbol = None
        if market:
            symbol = market['symbol']
        timestamp = self.safe_integer(trade, 'timestamp')
        price = self.safe_float(trade, 'price')
        amount = self.safe_float(trade, 'size')
        cost = None
        if price is not None:
            if amount is not None:
                cost = price * amount
        # you can't determine your side from maker/taker side and vice versa
        # you can't determine if your order/trade was a maker or a taker based
        # on just the side of your order/trade
        # https://github.com/ccxt/ccxt/issues/4300
        # side = 'sell' if (trade['maker_side'] == 'bid') else 'buy'
        side = None
        id = self.safe_string(trade, 'id')
        return {
            'info': trade,
            'timestamp': timestamp,
            'datetime': self.iso8601(timestamp),
            'symbol': symbol,
            'id': id,
            'order': None,
            'type': None,
            'side': side,
            'takerOrMaker': None,
            'price': price,
            'amount': amount,
            'cost': cost,
            'fee': None,
        }

    def fetch_trades(self, symbol, since=None, limit=50, params={}):
        self.load_markets()
        market = self.market(symbol)
        request = {
            'trading_pair_id': market['id'],
            'limit': limit,  # default 20, but that seems too little
        }
        response = self.publicGetMarketTradesTradingPairId(self.extend(request, params))
        trades = self.safe_value(response['result'], 'trades')
        return self.parse_trades(trades, market, since, limit)

    def parse_ohlcv(self, ohlcv, market=None, timeframe='5m', since=None, limit=None):
        return [
            # they say that timestamps are Unix Timestamps in seconds, but in fact those are milliseconds
            ohlcv['timestamp'],
            float(ohlcv['open']),
            float(ohlcv['high']),
            float(ohlcv['low']),
            float(ohlcv['close']),
            float(ohlcv['volume']),
        ]

    def fetch_ohlcv(self, symbol, timeframe='1m', since=None, limit=None, params={}):
        self.load_markets()
        market = self.market(symbol)
        #
        # they say in their docs that end_time defaults to current server time
        # but if you don't specify it, their range limits does not allow you to query anything
        #
        # they also say that start_time defaults to 0,
        # but most calls fail if you do not specify any of end_time
        #
        # to make things worse, their docs say it should be a Unix Timestamp
        # but with seconds it fails, so we set milliseconds(somehow it works that way)
        #
        endTime = self.milliseconds()
        request = {
            'trading_pair_id': market['id'],
            'timeframe': self.timeframes[timeframe],
            'end_time': endTime,
        }
        if since is not None:
            request['start_time'] = since
        response = self.publicGetChartCandlesTradingPairId(self.extend(request, params))
        ohlcv = self.safe_value(response['result'], 'candles')
        return self.parse_ohlcvs(ohlcv, market, timeframe, since, limit)

    def fetch_balance(self, params={}):
        self.load_markets()
        response = self.privateGetWalletBalances(params)
        result = {'info': response}
        balances = self.safe_value(response['result'], 'balances')
        for i in range(0, len(balances)):
            balance = balances[i]
            currencyId = self.safe_string(balance, 'currency')
            code = self.safe_currency_code(currencyId)
            account = self.account()
            account['used'] = self.safe_float(balance, 'on_order')
            account['total'] = self.safe_float(balance, 'total')
            result[code] = account
        return self.parse_balance(result)

    def parse_order_status(self, status):
        statuses = {
            'filled': 'closed',
            'rejected': 'closed',
            'partially_filled': 'open',
            'pending_cancellation': 'open',
            'pending_modification': 'open',
            'open': 'open',
            'new': 'open',
            'queued': 'open',
            'cancelled': 'canceled',
            'triggered': 'triggered',
        }
        return self.safe_string(statuses, status, status)

    def parse_order(self, order, market=None):
        #
        #     {
        #         'completed_at': None,
        #         'eq_price': '0',
        #         'filled': '0',
        #         'id': '88426800-beae-4407-b4a1-f65cef693542',
        #         'price': '0.00000507',
        #         'side': 'bid',
        #         'size': '3503.6489',
        #         'source': 'exchange',
        #         'state': 'open',
        #         'timestamp': 1535258403597,
        #         'trading_pair_id': 'ACT-BTC',
        #         'type': 'limit',
        #     }
        #
        symbol = None
        if market is None:
            marketId = self.safe_string_2(order, 'trading_pair', 'trading_pair_id')
            market = self.safe_value(self.markets_by_id, marketId)
        if market is not None:
            symbol = market['symbol']
        timestamp = self.safe_integer(order, 'timestamp')
        price = self.safe_float(order, 'price')
        average = self.safe_float(order, 'eq_price')
        amount = self.safe_float(order, 'size')
        filled = self.safe_float(order, 'filled')
        remaining = None
        cost = None
        if filled is not None and average is not None:
            cost = average * filled
        elif average is not None:
            cost = average * amount
        if amount is not None:
            if filled is not None:
                remaining = amount - filled
        status = self.parse_order_status(self.safe_string(order, 'state'))
        side = self.safe_string(order, 'side')
        if side == 'bid':
            side = 'buy'
        elif side == 'ask':
            side = 'sell'
        return {
            'id': self.safe_string(order, 'id'),
            'datetime': self.iso8601(timestamp),
            'timestamp': timestamp,
            'lastTradeTimestamp': None,
            'status': status,
            'symbol': symbol,
            'type': self.safe_string(order, 'type'),  # market, limit, stop, stop_limit, trailing_stop, fill_or_kill
            'side': side,
            'price': price,
            'cost': cost,
            'average': average,
            'amount': amount,
            'filled': filled,
            'remaining': remaining,
            'trades': None,
            'fee': None,
            'info': order,
        }

    def create_order(self, symbol, type, side, amount, price=None, params={}):
        self.load_markets()
        market = self.market(symbol)
        side = 'ask' if (side == 'sell') else 'bid'
        request = {
            'trading_pair_id': market['id'],
            'type': type,  # market, limit, stop, stop_limit
            'side': side,
            'size': self.amount_to_precision(symbol, amount),
        }
        if type != 'market':
            request['price'] = self.price_to_precision(symbol, price)
        response = self.privatePostTradingOrders(self.extend(request, params))
        order = self.parse_order(response['result']['order'], market)
        id = order['id']
        self.orders[id] = order
        return order

    def edit_order(self, id, symbol, type, side, amount, price, params={}):
        self.load_markets()
        request = {
            'order_id': id,
            'price': self.price_to_precision(symbol, price),
            'size': self.amount_to_precision(symbol, amount),
        }
        response = self.privatePutTradingOrdersOrderId(self.extend(request, params))
        return self.parse_order(self.extend(response, {
            'id': id,
        }))

    def cancel_order(self, id, symbol=None, params={}):
        self.load_markets()
        request = {
            'order_id': id,
        }
        response = self.privateDeleteTradingOrdersOrderId(self.extend(request, params))
        return self.parse_order(self.extend(response, {
            'id': id,
        }))

    def fetch_order(self, id, symbol=None, params={}):
        self.load_markets()
        request = {
            'order_id': str(id),
        }
        response = self.privateGetTradingOrdersOrderId(self.extend(request, params))
        return self.parse_order(response['result']['order'])

    def fetch_open_orders(self, symbol=None, since=None, limit=None, params={}):
        self.load_markets()
        result = self.privateGetTradingOrders(params)
        orders = self.parse_orders(result['result']['orders'], None, since, limit)
        if symbol is not None:
            return self.filter_by_symbol_since_limit(orders, symbol, since, limit)
        return self.filter_by_since_limit(orders, since, limit)

    def fetch_closed_orders(self, symbol=None, since=None, limit=None, params={}):
        self.load_markets()
        request = {}
        market = None
        if symbol is not None:
            market = self.market(symbol)
            request['trading_pair_id'] = market['id']
        if limit is not None:
            request['limit'] = limit  # default 50, max 100
        response = self.privateGetTradingOrderHistory(self.extend(request, params))
        orders = self.parse_orders(response['result']['orders'], market, since, limit)
        if symbol is not None:
            return self.filter_by_symbol_since_limit(orders, symbol, since, limit)
        return self.filter_by_since_limit(orders, since, limit)

    def fetch_order_trades(self, id, symbol=None, since=None, limit=None, params={}):
        self.load_markets()
        request = {
            'order_id': id,
        }
        response = self.privateGetTradingOrdersOrderIdTrades(self.extend(request, params))
        market = None if (symbol is None) else self.market(symbol)
        return self.parse_trades(response['result']['trades'], market)

    def fetch_my_trades(self, symbol=None, since=None, limit=None, params={}):
        self.load_markets()
        market = self.market(symbol)
        request = {}
        if symbol is not None:
            request['trading_pair_id'] = market['id']
        response = self.privateGetTradingTrades(self.extend(request, params))
        return self.parse_trades(response['result']['trades'], market, since, limit)

    def create_deposit_address(self, code, params={}):
        self.load_markets()
        currency = self.currency(code)
        # 'ledger_type' is required, see: https://cobinhood.github.io/api-public/#create-new-deposit-address
        ledgerType = self.safe_string(params, 'ledger_type', 'exchange')
        request = {
            'currency': currency['id'],
            'ledger_type': ledgerType,
        }
        response = self.privatePostWalletDepositAddresses(self.extend(request, params))
        address = self.safe_string(response['result']['deposit_address'], 'address')
        tag = self.safe_string(response['result']['deposit_address'], 'memo')
        self.check_address(address)
        return {
            'currency': code,
            'address': address,
            'tag': tag,
            'info': response,
        }

    def fetch_deposit_address(self, code, params={}):
        self.load_markets()
        currency = self.currency(code)
        request = {
            'currency': currency['id'],
        }
        response = self.privateGetWalletDepositAddresses(self.extend(request, params))
        #
        #     {success:    True,
        #        result: {deposit_addresses: [{      address: "abcdefg",
        #                                         blockchain_id: "eosio",
        #                                            created_at:  1536768050235,
        #                                              currency: "EOS",
        #                                                  memo: "12345678",
        #                                                  type: "exchange"      }]}}
        #
        addresses = self.safe_value(response['result'], 'deposit_addresses', [])
        address = None
        tag = None
        if len(addresses) > 0:
            address = self.safe_string(addresses[0], 'address')
            tag = self.safe_string_2(addresses[0], 'memo', 'tag')
        self.check_address(address)
        return {
            'currency': code,
            'address': address,
            'tag': tag,
            'info': response,
        }

    def withdraw(self, code, amount, address, tag=None, params={}):
        self.load_markets()
        currency = self.currency(code)
        request = {
            'currency': currency['id'],
            'amount': amount,
            'address': address,
        }
        if tag is not None:
            request['memo'] = tag
        response = self.privatePostWalletWithdrawals(self.extend(request, params))
        return {
            'id': None,
            'info': response,
        }

    def fetch_deposits(self, code=None, since=None, limit=None, params={}):
        self.load_markets()
        if code is None:
            raise ExchangeError(self.id + ' fetchDeposits() requires a currency code argument')
        currency = self.currency(code)
        request = {
            'currency': currency['id'],
        }
        response = self.privateGetWalletDeposits(self.extend(request, params))
        return self.parse_transactions(response['result']['deposits'], currency)

    def fetch_withdrawals(self, code=None, since=None, limit=None, params={}):
        self.load_markets()
        if code is None:
            raise ExchangeError(self.id + ' fetchWithdrawals() requires a currency code argument')
        currency = self.currency(code)
        request = {
            'currency': currency['id'],
        }
        response = self.privateGetWalletWithdrawals(self.extend(request, params))
        return self.parse_transactions(response['result']['withdrawals'], currency)

    def parse_transaction_status(self, status):
        statuses = {
            'tx_pending_two_factor_auth': 'pending',
            'tx_pending_email_auth': 'pending',
            'tx_pending_approval': 'pending',
            'tx_approved': 'pending',
            'tx_processing': 'pending',
            'tx_pending': 'pending',
            'tx_sent': 'pending',
            'tx_cancelled': 'canceled',
            'tx_timeout': 'failed',
            'tx_invalid': 'failed',
            'tx_rejected': 'failed',
            'tx_confirmed': 'ok',
        }
        return self.safe_string(statuses, status, status)

    def parse_transaction(self, transaction, currency=None):
        timestamp = self.safe_integer(transaction, 'created_at')
        currencyId = self.safe_string(transaction, 'currency')
        code = self.safe_currency_code(currencyId, currency)
        id = None
        withdrawalId = self.safe_string(transaction, 'withdrawal_id')
        depositId = self.safe_string(transaction, 'deposit_id')
        type = None
        address = None
        if withdrawalId is not None:
            type = 'withdrawal'
            id = withdrawalId
            address = self.safe_string(transaction, 'to_address')
        elif depositId is not None:
            type = 'deposit'
            id = depositId
            address = self.safe_string(transaction, 'from_address')
        additionalInfo = self.safe_value(transaction, 'additional_info', {})
        tag = self.safe_string(additionalInfo, 'memo')
        return {
            'info': transaction,
            'id': id,
            'txid': self.safe_string(transaction, 'txhash'),
            'timestamp': timestamp,
            'datetime': self.iso8601(timestamp),
            'address': address,
            'tag': tag,  # refix it properly
            'type': type,
            'amount': self.safe_float(transaction, 'amount'),
            'currency': code,
            'status': self.parse_transaction_status(transaction['status']),
            'updated': None,
            'fee': {
                'cost': self.safe_float(transaction, 'fee'),
                'rate': None,
            },
        }

    def sign(self, path, api='public', method='GET', params={}, headers=None, body=None):
        url = self.urls['api'] + '/' + self.version + '/' + self.implode_params(path, params)
        query = self.omit(params, self.extract_params(path))
        headers = {}
        if api == 'private':
            self.check_required_credentials()
            # headers['device_id'] = self.apiKey
            headers['nonce'] = str(self.nonce())
            headers['Authorization'] = self.apiKey
        if method == 'GET':
            query = self.urlencode(query)
            if len(query):
                url += '?' + query
        else:
            headers['Content-type'] = 'application/json; charset=UTF-8'
            body = self.json(query)
        return {'url': url, 'method': method, 'body': body, 'headers': headers}

    def handle_errors(self, code, reason, url, method, headers, body, response, requestHeaders, requestBody):
        if code < 400 or code >= 600:
            return
        if body[0] != '{':
            raise ExchangeError(self.id + ' ' + body)
        feedback = self.id + ' ' + self.json(response)
        errorCode = self.safe_value(response['error'], 'error_code')
        if method == 'DELETE' or method == 'GET':
            if errorCode == 'parameter_error':
                if url.find('trading/orders/') >= 0:
                    # Cobinhood returns vague "parameter_error" on fetchOrder() and cancelOrder() calls
                    # for invalid order IDs as well as orders that are not "open"
                    raise InvalidOrder(feedback)
        self.throw_exactly_matched_exception(self.exceptions, errorCode, feedback)
        raise ExchangeError(feedback)

    def nonce(self):
        return self.milliseconds()

    def _websocket_on_message(self, contextId, data):
        msg = json.loads(data)
        # console.log(msg)
        h = self.safe_value(msg, 'h', ['', '', ''])
        channel = h[0]
        version = h[1]
        type = h[2]
        if version != '2':
            self.emit('err', new ExchangeError(self.id + ' version response :' + version + ' != 2'), contextId)
            return
        parts = channel.split('.')
        id = parts[1]
        symbol = self._websocketFindSymbol(id)
        if type == 'error':
            self.emit('err', new ExchangeError(self.id + ' error ' + h[3] + ':' + h[4]))
        elif type == 'pong':
            pongTimeout = self._contextGet(contextId, 'pongtimeout')
            self._cancelTimeout(pongTimeout)
            self.emit('pong')
        elif channel.find('order-book.') >= 0:
            if type == 'subscribed':
                self._websocket_handle_subscription(contextId, 'ob', msg, symbol)
            elif type == 'unsubscribed':
                self._websocket_handle_unsubscription(contextId, 'ob', msg, symbol)
            elif type == 's':
                self._websocket_handle_order_book_snapshot(contextId, symbol, msg)
            elif type == 'u':
                self._websocket_handle_order_book_update(contextId, symbol, msg)
            else:
                self.emit('err', new ExchangeError(self.id + ' invalid orderbook message :' + type), contextId)
        elif channel.find('ticker.') >= 0:
            if type == 'subscribed':
                self._websocket_handle_subscription(contextId, 'ticker', msg, symbol)
            elif type == 'unsubscribed':
                self._websocket_handle_unsubscription(contextId, 'ticker', msg, symbol)
            elif type == 's':
                # snapshot???
                self._websocket_handle_ticker(contextId, symbol, msg)
            elif type == 'u':
                self._websocket_handle_ticker(contextId, symbol, msg)
            else:
                self.emit('err', new ExchangeError(self.id + ' invalid ticker message :' + type), contextId)
        elif channel.find('trade.') >= 0:
            if type == 'subscribed':
                self._websocket_handle_subscription(contextId, 'trade', msg, symbol)
            elif type == 'unsubscribed':
                self._websocket_handle_unsubscription(contextId, 'trade', msg, symbol)
            elif type == 's':
                # snapshot???
                self._websocket_handle_trade(contextId, symbol, msg)
            elif type == 'u':
                self._websocket_handle_trade(contextId, symbol, msg)
            else:
                self.emit('err', new ExchangeError(self.id + ' invalid trade message :' + type), contextId)
        elif channel.find('candle.') >= 0:
            if type == 'subscribed':
                self._websocket_handle_subscription(contextId, 'ohlcv', msg, symbol)
            elif type == 'unsubscribed':
                self._websocket_handle_unsubscription(contextId, 'ohlcv', msg, symbol)
            elif type == 's':
                # snapshot???
                self._websocket_handle_ohlcv(contextId, symbol, msg)
            elif type == 'u':
                self._websocket_handle_ohlcv(contextId, symbol, msg)
            else:
                self.emit('err', new ExchangeError(self.id + ' invalid ohlcv message :' + type), contextId)

    def _websocket_on_open(self, contextId, params):
        heartbeatTimer = self._contextGet(contextId, 'heartbeattimer')
        if heartbeatTimer is not None:
            self._cancelTimer(heartbeatTimer)
        heartbeatTimer = self._setTimer(contextId, 60000, self._websocketMethodMap('_websocketSendHeartbeat'), [contextId])
        self._contextSet(contextId, 'heartbeattimer', heartbeatTimer)

    def _websocket_on_close(self, contextId):
        heartbeatTimer = self._contextGet(contextId, 'heartbeattimer')
        if heartbeatTimer is not None:
            self._cancelTimer(heartbeatTimer)

    def _websocket_pong_timeout(self, contextId):
        ex = RequestTimeout(self.id + ' does not received pong message after 30 seconds')
        self.emit('err', ex, contextId)

    def _websocket_send_heartbeat(self, contextId):
        pongTimeout = self._setTimeout(contextId, 30000, self._websocketMethodMap('_websocketPongTimeout'), [contextId])
        self._contextSet(contextId, 'pongtimeout', pongTimeout)
        self.websocketSendJson({
            'action': 'ping',
        }, contextId)

    def _websocket_handle_order_book_snapshot(self, contextId, symbol, msg):
        d = self.safe_value(msg, 'd', {
            'bids': [],
            'asks': [],
        })
        ob = self.parse_order_book(d, None, 'bids', 'asks', 0, 2)
        symbolData = self._contextGetSymbolData(contextId, 'ob', symbol)
        symbolData['ob'] = ob
        self._contextSetSymbolData(contextId, 'ob', symbol, symbolData)
        self.emit('ob', symbol, self._cloneOrderBook(symbolData['ob'], symbolData['limit']))

    def _websocket_handle_order_book_update(self, contextId, symbol, msg):
        d = self.safe_value(msg, 'd', {
            'bids': [],
            'asks': [],
        })
        delta = self.parse_order_book(d, None, 'bids', 'asks', 0, 2)
        symbolData = self._contextGetSymbolData(contextId, 'ob', symbol)
        symbolData['ob'] = self.mergeOrderBookDeltaDiff(symbolData['ob'], delta)
        self._contextSetSymbolData(contextId, 'ob', symbol, symbolData)
        self.emit('ob', symbol, self._cloneOrderBook(symbolData['ob'], symbolData['limit']))

    def _websocket_handle_ticker(self, contextId, symbol, msg):
        d = self.safe_value(msg, 'd')
        timestamp = int(d[0])
        highestBid = float(d[1])
        lowestAsk = float(d[2])
        _24hVolume = float(d[3])
        _24hLow = float(d[4])
        _24High = float(d[5])
        _24hOpen = float(d[6])
        lastTradePrice = float(d[7])
        t = {
            'symbol': symbol,
            'timestamp': timestamp,
            'datetime': self.iso8601(timestamp),
            'high': _24High,
            'low': _24hLow,
            'bid': highestBid,
            'bidVolume': None,
            'ask': lowestAsk,
            'askVolume': None,
            'vwap': None,
            'open': _24hOpen,
            'close': lastTradePrice,
            'last': lastTradePrice,
            'previousClose': None,
            'change': None,
            'percentage': None,
            'average': None,
            'baseVolume': _24hVolume,
            'quoteVolume': None,
            'info': d,
        }
        self.emit('ticker', symbol, t)

    def _websocket_handle_trade(self, contextId, symbol, msg):
        data = self.safe_value(msg, 'd')
        if not isinstance(data, list):
            data = [data]
        trades = []
        for i in range(0, len(data)):
            d = data[i]
            tradeId = d[0]
            timestamp = int(d[1])
            makerSide = d[2]
            price = float(d[3])
            amount = float(d[4])
            cost = price * amount
            side = 'sell' if (makerSide == 'bid') else 'buy'
            t = {
                'info': d,
                'timestamp': timestamp,
                'datetime': self.iso8601(timestamp),
                'symbol': symbol,
                'id': tradeId,
                'order': None,
                'type': None,
                'side': side,
                'price': price,
                'amount': amount,
                'cost': cost,
                'fee': None,
            }
            trades.append(t)
        self.emit('trade', symbol, trades)

    def _websocket_handle_ohlcv(self, contextId, symbol, msg):
        data = self.safe_value(msg, 'd')
        if not isinstance(data, list):
            data = [data]
        dl = len(data)  # Transpiler is bugged
        if dl != 1:
            return None
        d = data[dl - 1]
        timestamp = int(d[0])
        volume = float(d[1])
        high = float(d[2])
        low = float(d[3])
        open = float(d[4])
        close = float(d[5])
        o = [
            timestamp,
            open,
            high,
            low,
            close,
            volume,
        ]
        self.emit('ohlcv', symbol, o)

    def _websocket_process_pending_nonces(self, contextId, nonceKey, event, symbol, success, ex):
        symbolData = self._contextGetSymbolData(contextId, event, symbol)
        if nonceKey in symbolData:
            nonces = symbolData[nonceKey]
            keys = list(nonces.keys())
            for i in range(0, len(keys)):
                nonce = keys[i]
                self._cancelTimeout(nonces[nonce])
                self.emit(nonce, success, ex)
            symbolData[nonceKey] = {}
            self._contextSetSymbolData(contextId, event, symbol, symbolData)

    def _websocket_handle_subscription(self, contextId, event, msg, symbol):
        self._websocket_process_pending_nonces(contextId, 'sub-nonces', event, symbol, True, None)

    def _websocket_handle_unsubscription(self, contextId, event, msg, symbol):
        self._websocket_process_pending_nonces(contextId, 'unsub-nonces', event, symbol, True, None)

    def _websocket_subscribe(self, contextId, event, symbol, nonce, params={}):
        if (event != 'ob') and (event != 'ticker') and (event != 'trade') and (event != 'ohlcv'):
            raise NotSupported('subscribe ' + event + '(' + symbol + ') not supported for exchange ' + self.id)
        # save nonce for subscription response
        symbolData = self._contextGetSymbolData(contextId, event, symbol)
        if not ('sub-nonces' in symbolData):
            symbolData['sub-nonces'] = {}
        id = self.market_id(symbol)
        payload = {
            'action': 'subscribe',
            'trading_pair_id': id,
        }
        if event == 'ob':
            symbolData['limit'] = self.safe_integer(params, 'limit', None)
            symbolData['precision'] = self.safe_integer(params, 'precision', '1E-6')
            payload['precision'] = symbolData['precision']
            payload['type'] = 'order-book'
        elif event == 'ticker':
            payload['type'] = 'ticker'
        elif event == 'trade':
            payload['type'] = 'trade'
        elif event == 'ohlcv':
            symbolData['timeframe'] = self.safe_integer(params, 'timeframe', '1m')
            payload['type'] = 'candle'
            payload['timeframe'] = symbolData['timeframe']
        nonceStr = str(nonce)
        handle = self._setTimeout(contextId, self.timeout, self._websocketMethodMap('_websocketTimeoutRemoveNonce'), [contextId, nonceStr, event, symbol, 'sub-nonce'])
        symbolData['sub-nonces'][nonceStr] = handle
        self._contextSetSymbolData(contextId, event, symbol, symbolData)
        # send request
        self.websocketSendJson(payload)

    def _websocket_unsubscribe(self, contextId, event, symbol, nonce, params={}):
        if (event != 'ob') and (event != 'ticker') and (event != 'trade') and (event != 'ohlcv'):
            raise NotSupported('unsubscribe ' + event + '(' + symbol + ') not supported for exchange ' + self.id)
        symbolData = self._contextGetSymbolData(contextId, event, symbol)
        if not ('unsub-nonces' in symbolData):
            symbolData['unsub-nonces'] = {}
        nonceStr = str(nonce)
        handle = self._setTimeout(contextId, self.timeout, self._websocketMethodMap('_websocketTimeoutRemoveNonce'), [contextId, nonceStr, event, symbol, 'unsub-nonces'])
        symbolData['unsub-nonces'][nonceStr] = handle
        self._contextSetSymbolData(contextId, event, symbol, symbolData)
        type = None
        if event == 'ob':
            type = 'order-book'
        elif event == 'ticker':
            type = 'ticker'
        elif event == 'trade':
            type = 'trade'
        elif event == 'ohlcv':
            type = 'candle'
        id = self.market_id(symbol)
        self.websocketSendJson({
            'action': 'unsubscribe',
            'type': type,
            'trading_pair_id': id,
        })

    def _websocket_timeout_remove_nonce(self, contextId, timerNonce, event, symbol, key):
        symbolData = self._contextGetSymbolData(contextId, event, symbol)
        if key in symbolData:
            nonces = symbolData[key]
            if timerNonce in nonces:
                self.omit(symbolData[key], timerNonce)
                self._contextSetSymbolData(contextId, event, symbol, symbolData)

    def _get_current_websocket_orderbook(self, contextId, symbol, limit):
        data = self._contextGetSymbolData(contextId, 'ob', symbol)
        if ('ob' in data) and (data['ob'] is not None):
            return self._cloneOrderBook(data['ob'], limit)
        return None
